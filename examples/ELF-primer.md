# New to ELF files? Start here

This is a short introduction to object files and executables, focusing on the ELF (Executable and Linkable Format).

Before discussing ELF itself, it helps to understand how source code in a compiled language is transformed into something the machine can execute.


## From source to executable

As you probably already know the transformation from source code into machine instructions is done by the compiler, what you may not know,
is that what the compiler outputs is not exactly an executable. In modern compiler it is, but this is only because when you are using tools like `gcc`, `clang`, or `rustc`  you are doing more than just compiling, they automatically invoke an additional step called *linking*. When you are making executables that run on top os general purpose OSes, like Windows or Linux, or using some SDK this linking step is always the same, so the compiler does it for you, but when you are doing interesting stuff, such as bare-metal systems, writing your own OS or anything trully low-level you will have to make some changes in this linking.

## The link editor

So what is this thing that compilers output and link editors (commonly called linkers) consume? They are called object files, object files contain the machine code generated from your source program but it is not the *whole* program, instead any program that comes from multiple sources generally produces multiple object files. Object files are essentially the modularity system of assemblers, linkers and other low level tools. Exactly how many source files combine to form an object file depends on the language, in C each `.c` file becomes an object file, but languages with more complex modularity systems may generate one object by module or maybe only one object for the entire program, but as you will see that is not very useful sometimes. An object file consists of the machine code instructions and data from whatever the compiler decided to group together
in the object as well as metadata describing what those instructions and data are and how to use them.

## Why the need for object level modularity?

At this point all this new complexity will likely digust you and the question of "why? wy all of this for an executable?" is a very reasonable question to have. The awnser is mostly to be able to split when and who compiles a part of the program. For simple programs all of the code is likely written by one person and all of the code comes from the same project, in those cases yes, object files don't make much sense, but when the project is more complex, and it may use huge third-party libraries it makes sense to compile it in different stages. Even if all the code is yours this split approach avoids having to recompile all the code each time, which may take a very long time and is wasted effort. And in the case of libraries, it doesn't make much sense that each person using the library has to copy the code and compile them themselves, it will be more efficient if it is compiled for the most common architectures and a binary (object file) is distributed instead.

Another need for this modularity comes from the need to hide the source code of certain modules of the system. This is a sad moment for hardcore Open Source fans but a real need of industry, companies spend a lot of effort in developing modules to be integrated in other external projects, if they were to provide the source code, that program could be replicated, by distributing the precompiled object, the company can hide all of the details of the code. Of course the object can be copied and distributed, but it is a lot easier to legally lincese and protect the usage of an static object file than to go into legal battles of proving that a code is close enough to another to ensure that is was copied and all of that boring stuff.

## Object formats

There are a lot of object file formats, usually each new OS tried to reinvent the format to better serve their needs, ELF is one of them, it is the one used by linux and most embedded platforms, but all object formats are very similar as they have the same purpose, they mostly differ on the details. And object file usually contains the following information:
* Metadata (version, architecture, etc.)
* Sections (contiguous regions of memory that contain a specific type of data)
* Export symbol table (What functions and variables from this file are public and can be used by other modules)
* Import symbol table (What functions and variables this object needs and are provided by other modules)
* Relocation information (Information on how to move the code into its final addresses in memory when making an executable)

There isn't much to say about metadata, its just information to ensure that objects are compatible and identifiable. Sections are a very important thing in linkers and objects, a section is essentially a block of data that shares the same properties or meaning, for example when compiling a module, the source program will have both instructions that tell the computer what to do, as well as variables that must be stored in memory, the resulting object will probably have a section for all the machine code, one instruction after another, and a data section, where all variables are grouped together to form a pool of memory where they are stored. When combining objects files to form the executable, similar sections are combined to form bigger sections, for example, the code sections are concatenated and the same is done for the data sections. This is more practical than having the space for the variables mixed with the code, by having them separated it is easier to place them in different places of memory and apply things like memory protection. Of course with a blob of binary data you will need some information on where exactly the functions and variables are placed, that information is provided by the export symbol table, wich contain offsets into the sections that indicate were a function or variable starts. Similarly when a function calls another in a different module, or writes to some global variable it needs to know where it will be, to indicate all of the missing addresses a import symbol table is created.
Finally we need some way to now how to patch our binary with the correct addresses of every symbol once the imports are resolved and the final addresses of each section are determined, that information is in the relocation table, which ensentially describes the operations needed to fix the code, such as changing a few zeroed bytes with the real address or adding an offset to a certain field and other architecture specific things.

A symbol is essentially a memory address of a function or variable that has not been determined yet, once the linker decides the final address of that function or variable all references to that symbol are replaced with that address.

## ELF files

In ELF the same concepts are represented, with the main difference with the abstract explanation above that both symbol tables are combined into a symbol table and each of the entries indicates if it is exported or imported. Another thing that makes ELF special (although most other object formats share this property) is that it can represent both objects, and the final executables made from them, executables have similar structure to an object as both are the very last stages of the compilation process so it makes sense to recycle the format to satisfy both use cases, executables drop the symbol tables as there is no symbol resolution to be done, as well as the relocation information because every section has already been relocated. But the concept of sections is still useful, the loader that will copy the executable in memory and jump to it will need similar information of which regions of memory it needs to copy and what attributes they have. In ELF this regions are not exactly the same as sections, they are called segments or program headers, but they are essentially the same thing, a continuous region of memory with the same kind of data inside. In particular segments relax a bit the importance of the "meaning" of a section and only cares about their atributes, for example multiple read-only sections may be combined into a single read-only segment.

This concludes the introduction to object formats, this is something that makes a lot more sense once you start playing with it and see a few examples, to understand the exact layout of an ELF file and what the insides of the programs you write look like I recomend that you follow the tutorial on making a readelf clone.